### HEAD - всему голова

Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый).

---

### git log

git log --oneline

```
f0e6542 (HEAD -> master, origin/master) Шпора готова по md
9e8b23e Добавление всякой фигни
```

выдаёт сокращённые хеши

git log --graph

```
* commit f0e65420ad60aa4bc15f02e8cd9bc2bd2e45a160 (HEAD -> master, origin/master)
| Author: parlament700 <alexfresh700@gmail.com>
| Date: Fri Feb 23 11:17:14 2024 +0700
|
| Шпора готова по md
|
* commit 9e8b23e06ec334dac6e4b2bb20ab281091747c6d
  Author: parlament700 <alexfresh700@gmail.com>
  Date: Fri Feb 23 11:06:49 2024 +0700
```

выдаёт граф и визуальное разделение веток

# Как исправить коммит?

Можно использовать `--amend`

**Важно** - _`--amend` используется только для последнего коммита_

---

### Дополнить коммит новыми файлами

Представьте, что делаете небольшой сайт и для этого создали файл-страницу `main.html`, а также файл со стилями `common.css`.

```
$ touch main.html
$ touch common.css
# дальше отредактировали оба файла
```

В какой-то момент вы забыли о файле `common.css` и добавили в коммит только `main.html`.

```
$ git add main.html
$ git commit -m "Добавить главную страницу"
$ git log --oneline
777fec3 Добавить главную страницу
```

Файл `common.css` так и остался _«висеть»_ в `untracked`. В этом легко убедиться, если вызвать `git status`.

```
$ git status
On branch main
Untracked files:
  (use "git add <file>..." to include in what will be committed)
          common.css

nothing added to commit but untracked files present (use "git add" to track)
```

Дополните последний коммит забытым файлом 'common.css' с помощью опции '--amend'.

```
$ git add common.css
# добавили файл common.css в список на коммит как обычно

# но вместо команды commit -m '...'
# будет:
$ git commit --amend --no-edit

$ git log --oneline
8340eb2 Добавить главную страницу
# коммит в истории всё ещё один (но у него новый хеш)
```

Обратите внимание на опцию `--no-edit`. Она сообщает команде `commit`, что сообщение коммита нужно оставить как было.

---

### Точно так же можно добавить не новый файл, а дополнительные изменения в уже добавленном в коммит файле.

```
# ещё раз отредактировали main.html

$ git add main.html # добавили в список на коммит
$ git commit --amend --no-edit
```

_Что же выбрать: новый коммит или --amend?_

В нашем примере вместо изменения последнего коммита можно было также выполнить новый коммит с одним файлом 'common.css'. Кажется, что так проще, но добавить изменения в уже существующий коммит может быть правильнее.
Например, через месяц кто-то захочет просмотреть историю изменений. Намного проще понять, что изменилось, если оба файла находятся в одном коммите. Иначе коммит со второй порцией изменений придётся искать.

---

### Изменить сообщение коммита

`git commit --amend -m "Новое сообщение"`

```
$ git commit --amend -m "Добавить главную страницу и стили"
$ git log --oneline
a31fa24 Добавить главную страницу и стили
```

---

### git commit --amend

_Без аргумента_ гит откроет редактор кода и можно будет _отредактировать код вручную_

# Как откатиться назад, если «всё сломалось»

- В список на коммит попал лишний файл (например, временный). Нужно «вынуть» его из списка.
- Последние несколько коммитов ошибочные: например, сделали не то, что было нужно, или нарушили логику. Хочется «откатить» сразу несколько коммитов, вернуть «как было вчера».
- Случайно изменился файл, который вообще не должен был меняться. Например, вы открыли не тот файл в редакторе и начали его исправлять.

---

### Выполнить unstage изменений — `git restore --staged <file>`

обратная команда `git add`

```
$ touch example.txt # создали ненужный файл
$ git add example.txt # добавили его в staged

$ git status # проверили статус
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   example.txt

$ git restore --staged example.txt
$ git status # проверили статус

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        example.txt

no changes added to commit (use "git add" and/or "git commit -a")
# файл example.txt из staged вернулся обратно в untracked
```

Вызов `git restore --staged example.txt` перевёл `example.txt` из `staged` обратно в `untracked`.
Чтобы «сбросить» все файлы из `staged` обратно в `untracked/modified`, можно воспользоваться командой `git restore --staged .`: она сбросит всю текущую папку (.).

### «Откатить» коммит — `git reset --hard <commit hash>`

`commit hash` - до какого коммита откатится

Будьте осторожны с командой git reset --hard! При удалении коммитов можно потерять что-то нужное.

---

### «Откатить» изменения, которые не попали ни в staging, ни в коммит, — `git restore <file>`

Может быть так, что вы случайно изменили файл, который не планировали. Теперь он отображается в `Changes not staged for commit` (`modified`). Чтобы вернуть всё «как было», можно выполнить команду `git restore <file>`.

```
# случайно изменили файл example.txt
$ git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
          modified:   example.txt

$ git restore example.txt
$ git status
On branch main
nothing to commit, working tree clean
```

Изменения в файле «откатятся» до последней версии, которая была сохранена через `git commit` или `git add`.

---

# Просматриваем изменения в файлах

`git diff`

Можно сравнивать изменения между некоторыми коммитами
`git diff <конец сказки> <начало>`

---

# .gitignore

Нужно просто создать `.gitignore` и в него запихнуть названия файлов которые должны игнорироваться

### Звёздочка (`*`)

```
# игнорировать все файлы, которые заканчиваются на .jpeg
*.jpeg

# игнорировать все файлы "tmp" во всех подпапках папки docs
docs/*/tmp
```

Теперь Git будет игнорировать все файлы, которые заканчиваются на `.jpeg` — пригодится тем, кто не любит картинки. А также все временные файлы `tmp` (от англ. temporary — «временный») в подпапках папки `docs`. Например, Git проигнорирует файл `docs/current/tmp`.

### Вопросительный знак (`?`)

Вопросительный знак `?` соответствует одному любому символу.

```
file?.txt
```

Если сохранить такую запись в `.gitignore`, то будут проигнорированы, например, файлы `fileA.txt` и `file1.txt`. А вот файл `file12.txt` не будет проигнорирован, потому что в его названии два символа после `file`, а не один.

### Квадратные скобки (`[…]`)

Квадратные скобки, как и вопросительный знак, соответствуют одному символу. При этом символ не любой, а только из списка, который указан в скобках.

```
# игнорировать файлы file0.txt, file1.txt и file2.txt
# при этом не игнорировать file3.txt, file4.txt, ...
file[0-2].txt
В скобках можно либо перечислить символы ([abc]), либо задать диапазон ([a-z]).
```

### Слеш (`/`)

Косая черта, или слеш (`/`), указывает на каталоги. Если шаблон в `.gitignore` начинается со слеша, то Git проигнорирует файлы или каталоги только в корневой директории.

```
# игнорировать todo.txt в корне репозитория
/todo.txt

# для сравнения: spam.txt будет игнорироваться во всех папках
spam.txt
```

Теперь файл `todo.txt` в корневом каталоге будет проигнорирован. При этом, например, файл `subdir/todo.txt` по-прежнему отслеживается.
Если шаблон заканчивается слешем, то правило применится только к папке.

```
# игнорировать папку build

build/
```

Обратите внимание: если build — это папка, то она будет проигнорирована. Если build — обычный файл, то он не подпадёт под правило и не будет игнорироваться.

### Парные звёздочки (`**`)

Функция парных звёздочек (`**`) похожа на функцию одинарной (`*`). Отличие в том, как они работают с вложенными папками. Двойная звёздочка может соответствовать любому количеству таких папок (в том числе нулю). Одинарная может соответствовать только одной.

```
# игнорировать файлы "docs/current/tmp", "docs/old/tmp",
# а также "docs/old/saved/a/b/c/d/tmp"
# и даже "docs/tmp", потому что ноль вложенных папок тоже подходит
docs/**/tmp

# игнорировать только "docs/current/tmp" и "docs/old/tmp"
# файл "docs/old/saved/a/b/c/d/tmp" не попадает в правило
docs/*/tmp
```

###VВосклицательный знак (`!`)

Любое правило в файле `.gitignore` можно инвертировать с помощью восклицательного знака (`!`).

```
# игнорировать все JPEG-файлы
*.jpeg

# но только не мем с Doge
!doge.jpeg
```

Теперь файл `doge.jpeg` будет отслеживаться, хотя остальные jpeg-файлы будут проигнорированы. Такие правила удобны для добавления исключений из других правил `.gitignore`.
